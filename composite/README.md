#### 对象容器的问题

在面向对象系统中，我们常会遇到一类具有"容器"特征的对象——即它们在充当对象的同时，又是其他对象的容器。

```java
public class SingleBox: IBox {
    public void process() { ……}
}

public class ContainerBox :IBox {
    public void process(){……}
    public ArrayList getBoxes(){……}
}
```

如果我们要对这样的对象容器进行处理

```java
IBox box=Factory.GetBox();

if (box is ContainerBox){
    box.process();
    ArrayList list= ((ContrainerBox) box).GetBoxes();
    // 将面临比较复杂的递归处理
}else if( box is SingleBox){
    box.process();
}
```

#### 介绍

组合模式（Composite）将对象组合成树形结构以表示"部分整体"的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

常见的场景有DOM机制，一个DOM节点可以包含子节点，不管是父节点还是子节点都有添加、删除、遍历子节点的通用功能。所以说组合模式的关键是要有一个抽象类，它既可以表示子元素，又可以表示父元素。

#### 动机

上述描述的问题根源在于：客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽
象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。

如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？

#### 意图

将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性

#### 结构

![结构图](../images/composite.01.png)

#### 几个要求

* Composite模式采用树形结构来实现普遍存在的对象容器，从而将"一对多"的关系转化为"一对一"的关系，使得客户代码可以一致地处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器

* 将"客户代码与复杂的对象容器结构"解耦是Composite模式的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的复内部实现结构——发生依赖关系，从而更能"应对变化"

* Composite模式中，是将"Add和Remove等和对象容器相关的方法"定义在“表示抽象对象的Component类"中，还是将其定义在“表示对象容器的Composite类"中，是一个关乎“透明性"和“安全性"的两难问题，需要仔细权衡。这里有可能违背面向对象的“单一职责原则”，但是对于这种特殊结构，这又是必须付出的代价。ASP.NET控件的实现在这方面为我们提供了一个很好的示范

* Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率

#### 使用场景

* 你想表示对象的部分-整体层次结构时

* 你希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法）
