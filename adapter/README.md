### Adapter (适配器模式 )

#### 适配（转换）的概念无处不在

适配，即在不改变原有实现的基础上，将原先不兼容的接口转换为兼容的接口

![图1](../images/adapter01.jpg)

![图2](../images/adapter02.jpg)

![图3](../images/adapter03.jpg)

适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作，速成包装器（wrapper）

#### 动机

在软件系统中，由于应用环境的变化，常常需要将 ``` 一些现存的对象 ``` 放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的

如何应对这种 ``` 迁移的变化 ```？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？

#### 意图

将一个类的接口转换成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。


#### 结构

对象适配器

![图4](../images/adapter04.jpg)

类适配器

![图5](../images/adapter05.jpg)

#### 几个要点

Adapter 模式主要应用于 ``` 希望复用一些现存的类，但是接口又与复用环境要求不一致的情况 ``` ，在遗留代码复用、类库迁移等方面非常有用

GoF 23 定义了两种 Adapter 模式的实现结构：对象适配器和类适配器，但类适配器采用 ``` 多继承 ``` 的实现方式，带来了不良的高耦合，所以一般不推荐使用。对象适配器采用 ``` 对象组合 ``` 的方式，更符合松耦合精神

Adapter 模式可以实现的非常灵活，不必拘泥于Gof23中定义的两种结构。例如，完全可以将Adapter 模式中的 ``` 现存对象 ``` 作为新的接口方法参数，来达到适配的目的。

Adapter 模式本身要求我们尽可能地使用 ``` 面向接口的编程 ``` 风格，这样才能在后期很方便地适配

#### 总结

##### 使用场景

* 使用一个已经存在的对象，但其方法或属性接口不符合你的要求

* 想创建一个可复用的对象，该对象可以与其它不相关的对象或不可见对象（即接口方法或属性不兼容的对象）协同工作

* 想使用已经存在的对象，但是不能对每一个都进行原型继承以匹配它的接口。对象适配器可以适配它的父对象接口方法或属性

##### 区别

* 适配器和桥接模式虽然类似，但桥接的出发点不同，桥接的目的是将接口部分和实现部分分离，从而对他们可以更为容易也相对独立的加以改变。而适配器则意味着改变一个已有对象的接口

* 装饰者模式增强了其它对象的功能而同时又不改变它的接口，因此它对应程序的透明性比适配器要好，其结果是装饰者支持递归组合，而纯粹使用适配器则是不可能的

* 代理模式在不改变它的接口的条件下，为另外一个对象定义了一个代理
